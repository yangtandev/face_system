# 定義服務列表
services:
    # 定義我們的主要應用程式服務
    face_system:
        # build 指令會告訴 docker-compose 使用當前目錄的 Dockerfile 來建構映像檔
        build: .
        # 為容器命名，方便我們透過名稱來管理它
        container_name: face_system_container
        # 設定容器的重啟策略：除非手動停止 (docker-compose down)，否則在退出時總是自動重啟
        restart: unless-stopped

        # --- 環境設定 ---
        environment:
            # 將主機的 DISPLAY 環境變數傳入容器。
            # 這是讓容器內的 GUI 應用程式知道在哪個螢幕上顯示畫面的關鍵。
            - DISPLAY=${DISPLAY}
            # 設定 QT 平台的外掛程式路徑，有助於解決在某些 Linux 環境下可能出現的 GUI 顯示問題
            - QT_X11_NO_MITSHM=1

        # --- 掛載設定 (Volumes) ---
        # command 指令讓我們可以覆寫 Dockerfile 中的預設 CMD
        # 這裡我們使用 shell 來執行一個複合指令：
        # 1. `rm -f /app/config.json`: 強制刪除可能存在的舊設定檔，-f 參數確保即使檔案不存在也不會報錯。
        # 2. `python3 /app/setting/bulid_config.py`: 執行腳本來建立一個全新的、基於預設值的設定檔。
        # 3. `python3 /app/face_main.py`: 最後，啟動主應用程式。
        # 用 `&&` 串連指令，確保前一個指令成功執行後，才會執行下一個。
        command: >
            sh -c "rm -f /app/config.json && python3 /app/setting/bulid_config.py && python3 /app/face_main.py"

        # --- 掛載設定 (Volumes) ---
        # volumes 讓我們可以將主機的檔案或資料夾，映射到容器內部
        volumes:
            # 將主機的 X11 socket 掛載到容器中。
            # 這是允許容器安全地與主機的圖形介面服務溝通的標準做法。
            - /tmp/.X11-unix:/tmp/.X11-unix

            # 將主機的 log 資料夾掛載到容器的 /app/log 資料夾。
            # 這樣，所有在容器內寫入 /app/log 的日誌檔案，都會被永久保存在主機的 log 資料夾中。
            - ./log:/app/log

            # 將其他可能由程式動態產生的資料夾也掛載出來，確保資料不隨容器刪除而遺失
            - ./media:/app/media
            - ./img_log:/app/img_log
            - ./voice:/app/voice

        # --- 硬體設備設定 ---
        # devices 讓我們可以將主機的硬體設備，直接映射給容器使用
        devices:
            # 將主機的 DRI (Direct Rendering Infrastructure) 設備掛載到容器中。
            # 這對於需要硬體加速的 GUI 應用程式至關重要，可以解決常見的 libGL 錯誤。
            - /dev/dri:/dev/dri
